# 设计模式

1. 依赖倒置原则DIP：高级模式（稳定）不应该依赖于低级模式（变化），两者都应该依赖于抽象；抽象（稳定）不应该依赖于具体实现（变化），具体实现而应该依赖于抽象。

​ 举例：以绘图为例。高级模式是绘图（draw），低级模式是各种图形(line, rectangle,...)，两者都应该依赖于形状(shape)。shape的是一个抽象类，其实现不依赖于各种图形的实现

2. 开放封闭原则OCP：对扩展（增加）开放，对更改封闭；类模块应该是可扩展的，但是不可修改的

​ 举例：桌椅生产公司面临一个新的需求，即生产的桌椅需要满足防火标准。此时，不应该是重新设计桌椅（改变），而应该是对桌椅涂装一层防火涂层（扩展）

3. 单一职责原则SRP：一个类应该仅有一个引起它变化的原因；变化的方向隐含着类的责任

​ 意义：即一个类的职责尽量单一

4. Liskov替换原则LSP：子类应该替换它的父类（基类，IS-A原则）；继承表达类型抽象

​ 举例：line类应该是一个shape类，能够调用基类的虚接口，如果不能调用虚接口，则不应该是基类的子类

5. 接口隔离原则ISP：不应该强迫客户程序依赖他们不用的方法；接口应该小而完备
6. 优先使用对象组合，而不是类继承：继承破坏封装性，增加耦合性；对象组合则指要求被组合的对象具有良好定义的接口，耦合度低
7. 封装变化点：使用封装创建对象之间的分界层，使设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的印象，从而实现层次间的松耦合
8. 针对接口编程，而不是针对实现编程：不将变量类型声明为某个具体的类，而是声明为某个接口；客户程序无需获知对象的具体类型，只需要知道对象所具有的接口；减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案

## 封装变化角度对模式分类
>
> 组件协作

- Template Method模版方法
- Observer/Event观察者模式
- Strategy策略模式

> 单一职责

*在软件组件的设计中，责任划分不清晰。使用继承得到的...，结果往往随着需求变化，子类急剧变化，同时充斥重复代码，这个时候的关键时划清责任。编译时复用，运行时变化*

- Decorator装饰者模式

1. 定义：又称包装模式。装饰模式就是要把添加的附加功能分别放在单独的类中，并让这个类包含它要装饰的对象
2. 实现步骤
    - 提供一个抽象组建类：抽象被装饰者的行为
    - 提供一个或多个具体组件类：被装饰者行为的具体实现
    - 提供一个抽象装饰器类：抽象组件指针与抽象组件一致的接口
    - 提供一个具体的装饰器类：为具体组件附加责任
![alt text](../../jpg/装饰者模式.png)

- Bridge桥接模式

1. 定义：桥接用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

2. 结构
    - 抽象Abstraction：定义抽象接口，通常包含对实现接口的引用
    - 扩展抽象Refined Abstraction：抽象类的子类或具体实现类
    - 实现Implementor：定义接口实现，提供基本操作的接口
    - 具体实现Concrete Implementor：实现实现接口的具体类
![alt text](../../jpg/桥接模式.png)

> 对象创建
> 对象性能
> 接口隔离
> 状态变化
> 数据结构
> 行为变化
> 领域问题
